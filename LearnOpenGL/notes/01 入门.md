LearnOpenGL笔记

# 简介

OpenGL是一个图形API，需要一个编程语言来工作，在这里使用的是C++。

C++推荐学习[www.learncpp.com](http://www.learncpp.com/)上的免费教程。



有时候ERR_CONNECTION_RESET，访问网站https://learnopengl-cn.github.io/ 进不去

解决方案：cmd执行

````
> ipconfig /flushdns
````

# 入门

## OpenGL

实际上不是一个API，而是一个API的规范。

也就是OpenGL库的实现可能不同，但功能相同。实际的OpenGL库的开发者通常是显卡的生产商（更新显卡驱动可能解决一些库bug）。

OpenGL3.3[规范文档](https://www.opengl.org/registry/doc/glspec33.core.20100311.withchanges.pdf)

### 核心模式与立即渲染模式

立即渲染模式（Immediate mode，也就是固定渲染管线），从OpenGL3.2开始，规范文档开始废弃立即渲染模式。

使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。

所有OpenGL的更高的版本都是在3.3的基础上，引入了额外的功能，并没有改动核心架构。

### 扩展

不同的opengl库支持特定的特性或渲染上的优化，通过扩展实现。最后可能成为规范的一部分。

### 状态机

OpenGL自身是一个巨大的状态机(State Machine)。

OpenGL上下文(Context)

状态设置函数(State-changing Function)

状态使用函数(State-using Function)

### 对象

OpenGL库是用C语言写的

C到其他高级语言的翻译，中间引入抽象层，对象是其一。

C风格的结构体。

>OpenGL上下文看作是一个大的结构体，通过一系列的方法来操作上下文中的信息，然后使用上下文来渲染。
>
>方法：创建对象，绑定对象，设置对象属性……将上下文设置回默认。

```c
// 创建对象
unsigned int objectId = 0;
glGenObject(1, &objectId);
// 绑定对象至上下文
glBindObject(GL_WINDOW_TARGET, objectId);
// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);
// 将上下文对象设回默认
glBindObject(GL_WINDOW_TARGET, 0);
```

objectId记录对象的id，可再次通过id绑定回这个对象。

这样可以创建多个对象，需要哪个绑定哪个，而不用重复设置属性了。

### 附加资源

- [opengl.org](https://www.opengl.org/)：OpenGL官方网站。
- [OpenGL registry](https://www.opengl.org/registry/)：包含OpenGL各版本的规范和扩展。

## 创建窗口

老：GLEW

新：GLAD

需要

1. OpenGL上下文(Context)
2. 一个用于显示的窗口

最流行的几个库有GLUT，SDL，SFML和GLFW。

### GLFW

专门针对OpenGL的C库

教程中使用的是VS2015，而我这里已经用了CMakeLists，准备不用sln做了。

环境：Win10+VS2019+CMakeLists.txt

#### 源码编译

https://www.glfw.org/download.html

下载当前版本3.3.4，Source package

VS2019打开CMakeLists.txt所在目录，等CMake生成完毕后，F5。

1. 我的默认生成的是x64-Debug，其他版本需要自己配一下
2. F5成功生成后，自动拉起demo boing.exe（demo目录`out\build\x64-Debug\examples`）
3. 库目录`out\build\x64-Debug\src\glfw3.lib`

#### 工程

glfw3.lib及include复制到当前的空项目中，并加入到CMakeLists.txt中

Windows平台，**opengl32.lib**已经包含在Microsoft SDK里了，将**opengl32.lib**添加进连接器设置里就行了。

在Linux下你需要链接**libGL.so**库文件，这需要添加`-lGL`到你的链接器设置中。如果找不到这个库你可能需要安装Mesa，NVidia或AMD的开发包，这部分因平台而异。

```cmake
target_include_directories(LearnOpenGL PUBLIC "ext/include")

target_link_directories(LearnOpenGL PUBLIC "ext/libs")
target_link_libraries(LearnOpenGL PUBLIC
	glfw3.lib
	opengl32.lib
)
```



```c++
#include <GLFW\glfw3.h>
```

### GLAD

由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要**在运行时获取函数地址**并将其保存在一个函数指针中供以后使用。

```c
typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);
GL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)wglGetProcAddress("glGenBuffers");
```

GLAD是用来简化这个过程的。

#### 配置GLAD

https://glad.dav1d.de/

Language: C/C++

Specification: OpenGL

API: gl3.3

Profile: Core

Options: Generate a loader

下载zip，解压，按照教程复制头文件到include目录（**glad**和**KHR**）

### 附加资源

- [GLFW: Window Guide](http://www.glfw.org/docs/latest/window_guide.html)：GLFW官方的配置GLFW窗口的指南。
- [Building applications](http://www.opengl-tutorial.org/miscellaneous/building-your-own-c-application/)：提供了很多编译或链接相关的信息和一大列错误及对应的解决方案。
- [GLFW with Code::Blocks](http://wiki.codeblocks.org/index.php?title=Using_GLFW_with_Code::Blocks)：使用Code::Blocks IDE编译GLFW。
- [Running CMake](http://www.cmake.org/runningcmake/)：简要的介绍如何在Windows和Linux上使用CMake。
- [Writing a build system under Linux](http://learnopengl.com/demo/autotools_tutorial.txt)：Wouter Verholst写的一个autotools的教程，讲的是如何在Linux上编写构建系统，尤其是针对这些教程。
- [Polytonic/Glitter](https://github.com/Polytonic/Glitter)：一个简单的样板项目，它已经提前配置了所有相关的库；如果你想要很方便地搞到一个LearnOpenGL教程的范例工程，这也是很不错的。

## 你好，窗口

在包含GLFW的头文件之前包含GLAD的头文件。

报错：

```
error LNK2019: 无法解析的外部符号 gladLoadGLLoader，函数 main 中引用了该符号
```

除了要包含GLAD的头文件，src中的c文件也要编译进去

glViewport指定窗口左下角位置和渲染窗口的宽高。

【?】对于视网膜(Retina)显示屏，width和height都会明显比原输入值更高一点。

**Render Loop**

**双缓冲(Double Buffer)**

输入`glfwGetKey`

当调用`glClear`函数，清除颜色缓冲之后，整个颜色缓冲都会被填充为`glClearColor`里所设置的颜色。

- `glClearColor`函数是一个**状态设置**函数
- `glClear`函数则是一个**状态使用**的函数

